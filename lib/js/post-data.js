export function getPostContent(id) {
		switch (id) {
		case 1:
			return `안녕하세요! 백엔드 개발자 Rabbit입니다. 다들 Java하면 커피부터 떠올리시죠? 맞습니다. 근데 그게 다가 아니에요. 지금 여러분이 쓰는 수많은 웹사이트, 앱들이 바로 이 Java 위에서 돌아가고 있습니다. 오늘은 이 Java가 대체 뭐고, 왜 우리가 이걸 알아야 하는지 좀 씹어보는 시간을 갖겠습니다.\n### 그래서 Java가 뭔데?\n컴퓨터랑 대화하는 방법 중 하나죠. 1995년에 나왔으니 벌써 꽤 오래됐는데, 아직도 현업에서 쌩쌩한 이유? '한 번 만들면 어디서든 돌아간다'는 컨셉, 이게 핵심입니다. 윈도우, 맥, 리눅스 가리지 않고 다 돌아가거든요. 이걸 플랫폼 독립성이라고 부릅니다.\n그리고 안정성이 중요해요. 문법이 좀 빡빡한 대신, 런타임 에러를 미리 잡을 수 있게 설계돼 있어서 은행이나 증권사 같은 미션 크리티컬한 시스템에서 선호하죠. 마지막으로, 라이브러리가 정말 많습니다. 이미 잘 만들어진 부품(라이브러리)들이 널려있어서, 개발자들은 이걸 가져다가 조립만 잘하면 되니 생산성이 확 올라갑니다.\n### 왜 Java를 해야 되는데?\n프로그래밍 입문하신다면, Java 괜찮은 선택입니다.\n1.  객체 지향(OOP) 제대로 배우기: 복잡한 세상을 역할과 책임에 따라 나누는 '객체' 개념을 배우기 가장 좋은 언어입니다. 이게 몸에 익으면 문제 해결 능력이 달라져요.\n2.  먹고 살기: 안드로이드 앱, 웹 서버, 빅데이터, AI... 안 쓰이는 곳 찾기가 더 힘듭니다. 일자리가 많다는 뜻이죠.\n3.  든든한 커뮤니티: 오래된 만큼, 구글에 물어보면 웬만한 문제는 다 해결됩니다. 혼자 끙끙 앓을 필요가 없어요.\n코딩은 그냥 기술이 아닙니다. 논리적으로 생각하고 문제를 부수는 능력을 기르는 훈련이죠. 그 첫 단추, Java로 끼워보는 거, 나쁘지 않은 선택일 겁니다.`
		case 2:
			return `안녕하세요! 백엔드 개발자 Rabbit입니다. 웹 개발 좀 해보신 분들은 알겠지만, 로그인, DB 연결, 보안 설정... 이거 맨날 하는 거잖아요. Spring은 바로 이런 반복 작업을 대신 해주는 '만능 공구함' 같은 녀석입니다. 덕분에 우린 좀 더 핵심적인 비즈니스 로직에만 집중할 수 있죠.\n### Spring Framework: 뼈대 튼튼한 국밥\nJava 웹 개발의 표준, 근본이죠. 오랫동안 수많은 실무 프로젝트에서 검증됐습니다. 안정성, 성능 다 좋죠. 근데 솔직히 좀 무겁고, 설정할 게 많아서 처음엔 좀 버거울 수 있습니다. XML 설정 지옥... 겪어본 분들은 아실 겁니다.\n### Spring Boot: 빠르고 간편한 초밥\n그래서 나온 게 Spring Boot입니다. 복잡한 설정? 다 알아서 해줍니다. 'Just run it'이 가능해진 거죠. 개발자는 진짜 필요한 코드 몇 줄만 짜면 바로 웹서버 띄우고 개발 시작입니다.\n   자동 설정: 필요한 라이브러리만 넣으면 알아서 다 설정해줍니다.\n   내장 서버: Tomcat 같은 거 따로 설치할 필요 없이 그냥 내장돼있어요. 실행이 정말 편합니다.\n   간결한 코드: 기존 Spring보다 훨씬 코드 양이 줄어듭니다.\n결론적으로 Spring Boot는 Spring의 안정성은 그대로 가져오면서, 개발 생산성을 극적으로 끌어올린 물건입니다. 요즘 Java 웹은 거의 다 Spring Boot 쓴다고 보면 됩니다.`
		case 3:
			return `안녕하세요! 백엔드 개발자 Rabbit입니다. OOP, 객체 지향 프로그래밍. 말은 많이 들어보셨죠? 어렵게 생각할 거 없습니다. 그냥 프로그램을 레고 블록 조립하듯이 만드는 거라고 생각하면 편해요. 각 블록(객체)이 자기 할 일을 하고, 얘네들을 모아서 더 큰 프로그램을 만드는 거죠.\n### 객체 지향, 왜 써야 할까?\n1.  재사용성: 잘 만들어둔 블록은 다른 데서 또 쓸 수 있잖아요? 개발 속도가 빨라집니다.\n2.  유지보수: 문제 생기면 그 블록만 갈아끼우면 됩니다. 전체를 다 뜯어고칠 필요가 없죠.\n3.  확장성: 새 기능? 새 블록 만들어서 끼우면 됩니다. 기존 코드는 건드릴 필요가 없으니 안전하죠.\nJava가 바로 이 객체 지향의 대표주자입니다. 이걸 이해해야 Java를 제대로 쓸 수 있습니다.`
		case 4:
			return `안녕하세요! 백엔드 개발자 Rabbit입니다. 코드 보다 보면 골뱅이(@)로 시작하는 이상한 거, 많이 보셨을 겁니다. 이게 바로 어노테이션인데, 일종의 '꼬리표'라고 생각하면 됩니다. 그냥 주석이랑 다른 점은, 이 꼬리표를 컴파일러나 프레임워크가 보고 특별한 동작을 한다는 거죠.\n### 어노테이션, 왜 쓰는 걸까?\n한마디로, 코드를 줄이고 깔끔하게 만들려고 씁니다. 예를 들어 Spring에서 \`@RestController\` 딱 한 줄 붙여주면, 이 클래스가 API 컨트롤러라는 걸 프레임워크에 알려주고, 알아서 JSON으로 응답도 만들어주고... 복잡한 설정 코드가 확 줄어듭니다.\n개발자는 '뭘 할지'에만 집중하고, '어떻게 할지'는 프레임워크에 맡기는 거죠. 어노테이션은 바로 그 소통의 도구입니다.`
		case 5:
			return `안녕하세요! 백엔드 개발자 Rabbit입니다. Spring으로 웹 개발하다 보면, 기본 설정 말고 뭔가 좀 더 만지고 싶을 때가 있습니다. 특정 요청을 중간에 가로채거나, 정적 파일(이미지, CSS, JS) 경로를 따로 잡아주거나 할 때 말이죠. 이때 쓰는 게 바로 \`WebMvcConfigurer\`입니다.\n### WebMvcConfigurer로 뭘 할 수 있나?\n   인터셉터 추가: 컨트롤러 실행 전후에 공통 로직(로그인 체크, 로깅 등)을 끼워 넣을 수 있습니다. AOP랑 비슷하죠.\n   뷰 컨트롤러 설정: 단순 페이지 이동 같은 건 컨트롤러 없이 URL이랑 HTML 파일만 바로 연결할 수 있습니다.\n   정적 리소스 핸들링: \`/static/**\` 같은 요청이 오면 \`resources/static/\` 폴더에서 파일을 찾아라, 이런 규칙을 정해줄 수 있습니다.\n\`WebMvcConfigurer\`를 쓰면 Spring MVC의 동작을 내 입맛에 맞게 바꿀 수 있어서, 좀 더 유연한 개발이 가능해집니다.`
		case 6:
			return `안녕하세요! 백엔드 개발자 Rabbit입니다. 요즘 웹 서비스에서 사용자 인증 어떻게 하냐 물어보면 JWT 얘기가 꼭 나오죠. JSON Web Token, 말 그대로 JSON을 웹 토큰으로 쓰는 겁니다. 유저 정보나 권한 같은 걸 담아서 암호화한 문자열인데, 위조가 어렵고 서버에 부담을 덜 줘서 많이 씁니다.\n### JWT, 왜 쓰는가?\n옛날에는 서버가 유저 정보를 세션에 다 들고 있었어요. 근데 유저가 많아지거나 서버를 여러 대 두면 이 세션 관리가 골치 아파집니다. JWT는 토큰 안에 정보를 다 담고, 서버는 그냥 이 토큰이 유효한지만 검증하면 되니까 'Stateless'한 구조를 만들기 좋습니다.\n   무상태(Stateless): 서버가 유저 상태를 저장할 필요가 없으니 서버 부담이 줄고, 확장성이 좋아집니다.\n   확장성: MSA 환경처럼 여러 서비스에서 같은 토큰으로 인증 처리가 가능합니다.\n   보안성: 암호화된 서명이 있어서 중간에 누가 내용을 바꿔도 바로 알아챌 수 있습니다.\n주로 모바일 앱이나 SPA(Single Page Application)처럼 클라이언트-서버가 분리된 구조에서 인증/인가 용도로 널리 쓰입니다.`
		case 7:
			return `안녕하세요! 백엔드 개발자 Rabbit입니다. 프론트엔드랑 백엔드랑 서버 분리해서 개발하다 보면 꼭 만나는 에러가 있죠. 바로 CORS(Cross-Origin Resource Sharing) 에러입니다. 브라우저에는 기본적으로 '동일 출처 정책(Same-Origin Policy)'이라는 보안 규칙이 있어서, 다른 도메인에서 오는 요청을 막아버립니다.\n### CORS, 왜 필요한가?\n만약 이게 없다면, 악성 사이트가 우리가 모르는 사이에 다른 사이트(은행 같은)에 요청을 보내서 정보를 빼갈 수도 있겠죠. 이런 걸 막기 위한 보안 장치입니다.\nCORS는 서버에서 "어, http://localhost:3000에서 오는 요청은 괜찮아. 허락해줄게"라고 응답 헤더에 명시해주는 방식입니다. 그럼 브라우저가 그 헤더를 보고 "아, 허락된 요청이구나"하고 통과시켜주는 거죠.\n백엔드 개발자는 보통 \`WebMvcConfigurer\` 같은 곳에 어떤 출처(Origin)와 어떤 HTTP 메소드를 허용할지 설정해주는 코드를 추가해서 이 문제를 해결합니다.`
		case 8:
			return `안녕하세요! 백엔드 개발자 Rabbit입니다. Spring Boot 프로젝트에 Spring Security 의존성을 추가하는 순간, 모든 요청은 막히기 시작합니다. 바로 이 시큐리티 설정을 담당하는 핵심 파일이 \`SecurityConfig\`입니다. 건물로 치면 모든 출입문과 CCTV를 통제하는 보안실 같은 곳이죠.\n### SecurityConfig에서 뭘 설정하나?\n   인증(Authentication): 누구인지 확인하는 절차. 아이디/비번 로그인 처리 같은 걸 설정합니다.\n   인가(Authorization): 인증된 사용자가 어디까지 접근할 수 있는지 권한을 설정합니다. \`/admin/**\` 경로는 ADMIN 롤만, \`/user/**\` 경로는 USER 롤만 접근 가능하게 하는 식이죠.\n   로그인/로그아웃 처리: 로그인 페이지는 어디인지, 성공하면 어디로 보낼지, 실패하면 어떻게 할지 등을 다 정해줍니다.\n   CSRF, CORS 설정: 웹 보안 관련 설정들도 여기서 다룹니다.\n\`SecurityConfig\`를 잘 다루는 건 Spring 기반 백엔드 개발자의 기본 소양입니다. 이걸 알아야 안전한 서비스를 만들 수 있죠.`
		case 9:
			return `안녕하세요! 백엔드 개발자 Rabbit입니다. Java 21 나오면서 가장 핫했던 주제가 바로 이 가상 스레드(Virtual Threads), 프로젝트 룸(Project Loom)의 결과물이죠. 기존 스레드는 OS 스레드랑 1:1로 매핑돼서 비싸고, 몇만 개씩 만들면 서버가 힘들어했습니다. 근데 요즘 웹 서비스는 동시 요청이 어마어마하잖아요? 기존 모델로는 한계가 명확했죠.\n### 가상 스레드, 원리가 뭔가?\n가상 스레드는 JVM이 직접 관리하는 아주 가벼운 스레드입니다. OS 스레드에 직접 매핑되지 않고, M:N 매핑, 즉 수백만 개의 가상 스레드를 소수의 플랫폼 스레드(OS 스레드)가 돌려쓰는 방식입니다. I/O 작업처럼 스레드가 놀게 되면(blocking), 플랫폼 스레드는 다른 가상 스레드에게 CPU를 양보하고 계속 일을 합니다. 덕분에 적은 리소스로 엄청난 동시성을 뽑아낼 수 있게 된 거죠.\n### 뭐가 좋아지나?\n   높은 처리량: 특히 I/O 작업이 많은 애플리케이션에서 성능이 극적으로 향상됩니다.\n   단순한 코드: 복잡한 비동기 코드(Callback Hell, Future, RxJava...) 없이, 그냥 평소 짜던 동기 코드 스타일 그대로 높은 동시성을 누릴 수 있습니다. 이게 핵심입니다.\n   자원 효율성: 스레드 생성 비용이나 컨텍스트 스위칭 비용이 거의 없다시피 해서 메모리 사용량이 확 줄어듭니다.\n가상 스레드는 Java 생태계의 게임 체인저가 될 겁니다. 모든 Java 개발자들이 반드시 알아야 할 내용이죠.`
		case 10:
			return `안녕하세요! 백엔드 개발자 Rabbit입니다. Java 개발자는 \`new\`로 객체를 만들지만 \`delete\`는 안 하죠. JVM의 GC(Garbage Collector)가 알아서 안 쓰는 객체(쓰레기)를 치워주니까요. 편하긴 한데, 이 GC가 어떻게 돌아가는지 모르면 언젠가 터질 시한폭탄(성능 이슈)을 안고 가는 것과 같습니다.\n### GC 기본 원리: Mark and Sweep\n1.  Mark: 일단 GC Roots(스택, static 변수 등)에서 시작해서, 연결된 모든 객체에 '살아있음' 표시를 합니다.\n2.  Sweep: 표시 안 된 객체들, 즉 쓰레기들을 싹 다 치웁니다.\n3.  Compact: 여기저기 흩어진 메모리 조각들을 한 곳으로 모아서(Compaction), 다음 객체 할당이 빠르게 되도록 정리합니다.\n### Young vs Old Generation\nJVM 힙은 크게 Young과 Old 영역으로 나뉩니다.\n   Young Generation: 갓 생성된 객체들이 사는 동네. 여기서 일어나는 GC를 'Minor GC'라고 하고, 아주 빈번하게 발생합니다. 여기서 살아남으면 Old로 넘어갑니다.\n   Old Generation: 오랫동안 살아남은 객체들이 사는 동네. 여기서 일어나는 GC를 'Major GC' 또는 'Full GC'라고 합니다. 이게 발생하면 애플리케이션이 잠시 멈추는 'Stop-the-world'가 생겨서 성능에 치명적일 수 있습니다.\n### 진화하는 GC 알고리즘\n요즘은 G1 GC가 대세고, 더 나아가 ZGC, Shenandoah GC처럼 Stop-the-world를 거의 밀리초 단위까지 줄인 GC들도 나왔습니다. GC 튜닝은 백엔드 성능 최적화의 핵심 과제 중 하나입니다.`
		case 11:
			return `안녕하세요! 백엔드 개발자 Rabbit입니다. TDD, 테스트 주도 개발. 말 그대로 테스트가 개발을 이끌어가는 방식입니다. 코드 짜기 전에 실패하는 테스트부터 먼저 짜는 거죠. '실패(Red) -> 성공(Green) -> 리팩토링(Refactor)' 이 사이클을 계속 반복하면서 코드를 완성해나갑니다.\n### TDD 사이클: Red-Green-Refactor\n1.  Red: 요구사항을 검증할 테스트 코드를 먼저 짭니다. 기능이 없으니 당연히 테스트는 깨지겠죠.\n2.  Green: 이 테스트를 통과시킬 가장 간단한 코드를 짭니다. 어떻게든 통과만 시키는 게 목표입니다.\n3.  Refactor: 테스트가 통과하는 상태를 유지하면서, 코드 퀄리티를 높이는 작업(중복 제거, 구조 개선 등)을 합니다.\n### TDD, 왜 해야 할까?\n   설계 개선: 테스트를 먼저 짜다 보면 자연스럽게 코드의 역할과 책임을 고민하게 돼서, 설계가 깔끔해집니다.\n   안정성: 코드가 테스트로 다 덮여있으니, 리팩토링하거나 새 기능을 추가할 때 버그가 생길까 봐 무서워할 필요가 없습니다. 든든한 안전망이 생기는 거죠.\n   자신감: 언제든 테스트를 돌려서 내 코드가 잘 돌아간다는 걸 확인할 수 있으니, 자신감을 갖고 개발할 수 있습니다.\nJava에서는 보통 JUnit으로 테스트를 짜고, Mockito 같은 걸로 의존성을 격리해서 깔끔한 단위 테스트를 만듭니다. TDD는 단순한 테스트 기법이 아니라, 소프트웨어를 만드는 철학에 가깝습니다.`
		case 12:
			return `안녕하세요! 백엔드 개발자 Rabbit입니다. Java 8이 나오면서 가장 혁신적인 변화를 꼽으라면 단연 Stream API일 겁니다. for-loop와 if-else로 도배되던 코드를 훨씬 간결하고 우아하게 바꿔줬죠.\n### Stream의 핵심\n   선언적 프로그래밍: '어떻게'가 아니라 '무엇을' 할 건지만 코드로 표현합니다.\n   파이프라이닝: 여러 연산을 체인처럼 연결해서 처리합니다. \`map().filter().collect()\` 이런 식으로요.\n   내부 반복: 개발자가 직접 반복문을 돌리는 게 아니라, 스트림이 알아서 내부적으로 처리합니다.\n### Stream, 좀 더 깊게 써보기\n   flatMap: 중첩된 리스트를 단일 스트림으로 펼칠 때 씁니다. \`List<List<String>>\`을 \`Stream<String>\`으로 만들 때 유용하죠.\n   groupingBy: SQL의 \`GROUP BY\`처럼 데이터를 그룹핑해서 Map으로 만들어줍니다. 정말 강력한 기능입니다.\n   Collectors.toMap: 스트림 결과를 Map으로 바꿀 때 씁니다. 키 중복 처리 로직을 잘 다루는 게 중요합니다.\n   parallelStream: 데이터가 많을 때 \`parallelStream()\` 한 줄이면 병렬 처리로 성능을 높일 수 있습니다. 물론, 항상 빨라지는 건 아니니 잘 알고 써야 합니다.\nStream API를 잘 쓰는 건 이제 현대 Java 개발자의 기본기입니다. 코드가 짧아지는 건 덤이고, 데이터 처리 로직을 명확하게 표현할 수 있다는 게 진짜 장점이죠.`
		case 13:
			return `안녕하세요! 백엔드 개발자 Rabbit입니다. 오늘은 Google이 안드로이드 공식 개발 언어로 지정하면서 더욱 핫해진 언어, Kotlin에 대해 이야기해보려고 합니다. Java와 100% 호환되면서도 더 간결하고 안전한 코드를 작성할 수 있어 많은 개발자들의 사랑을 받고 있죠.\n### Kotlin, 왜 매력적일까?\n1.  간결한 문법: Java의 상용구(Boilerplate) 코드를 대폭 줄여줍니다. 데이터 클래스, 확장 함수 등의 기능으로 생산성이 크게 향상됩니다.\n2.  Null 안전성: Kotlin의 타입 시스템은 Null Pointer Exception(NPE)을 근본적으로 방지하도록 설계되었습니다. \`?\`와 \`!!\` 연산자를 통해 Null을 안전하게 다룰 수 있습니다.\n3.  Java와 100% 호환: 기존 Java 코드와 완벽하게 함께 작동합니다. Java 프로젝트에 점진적으로 Kotlin을 도입할 수 있고, Java 라이브러리를 그대로 사용할 수 있습니다.\n4.  다양한 플랫폼 지원: 안드로이드 앱 개발은 물론, Spring Boot를 이용한 서버 개발, Kotlin/JS를 통한 프론트엔드 개발, 심지어 네이티브 앱 개발까지 가능합니다.\nJava 개발자라면 Kotlin을 배우는 것은 선택이 아닌 필수 역량이 되어가고 있습니다. 더 즐겁고 생산적인 개발을 원한다면, 지금 바로 Kotlin의 세계에 입문해보세요.`
		case 14:
			return `안녕하세요! 백엔드 개발자 Rabbit입니다. 오늘은 Spring Boot, Quartz, React를 활용하여 직접 개발한 '풀스택 동적 스케줄러' 프로젝트에 대해 소개합니다. 이 프로젝트는 반복적인 작업을 유연하게 관리하고, 웹 UI를 통해 실시간으로 스케줄을 제어할 수 있도록 설계되었습니다.\n\n### 프로젝트 개요\n*   목적: 특정 시간에 반복 실행되는 작업을 동적으로 등록, 조회, 실행, 중단, 재개, 삭제하는 시스템.\n*   백엔드: Spring Boot 3.x (Java, Gradle), Spring Data JPA (MySQL), Spring Security, Quartz (스케줄링). REST API 제공.\n*   프론트엔드: React (axios, react-router-dom)를 사용하여 백엔드와 상호작용하는 사용자 인터페이스.\n\n### 주요 기능\n1.  동적 스케줄링: 런타임 중에도 스케줄을 등록하고 변경 가능.\n2.  영속성: 데이터베이스(MySQL)에 스케줄 정보를 저장하여 서버 재시작 후에도 유지.\n3.  유연한 작업 정의: Cron 표현식을 사용하여 복잡한 반복 규칙 설정.\n4.  웹 UI: React 기반의 직관적인 UI를 통해 스케줄러를 쉽게 관리.\n\n### 백엔드 핵심 구성\n*   Quartz 통합: \spring-boot-starter-quartz\를 통해 Quartz 스케줄러를 Spring Boot에 통합. \SchedulerConfig.java\에서 스레드 풀, 저장 방식 등을 설정.\n*   데이터 관리: \SchedulerJob.java\ 엔티티로 스케줄 정보를 정의하고, \SchedulerJobRepository.java\를 통해 DB CRUD 수행.\n*   비즈니스 로직: \SchedulerService.java\에서 스케줄러 등록, 실행, 중단, 재개, 삭제 등 핵심 비즈니스 로직 구현.\n*   API 엔드포인트: \SchedulerController.java\에서 RESTful API를 제공하여 프론트엔드와 통신.\n*   보안 및 CORS: \SecurityConfig.java\와 \CorsConfig.java\를 통해 API 보안 및 프론트엔드와의 통신 문제 해결.\n*   초기화: \SchedulerInitializer.java\를 통해 서버 시작 시 DB와 Quartz 스케줄러 상태 동기화.\n\n### 프론트엔드 핵심 구성\n*   \SchedulerPage.jsx\: 스케줄러 목록 표시 및 관리 기능 제공.\n*   \SchedulerForm.jsx\: 새로운 스케줄 등록 및 기존 스케줄 수정 폼.\n*   \schedulerApi.js\: 백엔드 API 호출을 위한 모듈.\n\n이 프로젝트는 실용적인 백엔드 스케줄링 시스템을 구축하고, 프론트엔드와 연동하는 과정을 경험하기에 좋은 예시가 될 것입니다.`;
		case 15:
			return `안녕하세요! 백엔드 개발자 Rabbit입니다. '제 컴퓨터에선 되는데...' 이 말, 개발자라면 한 번쯤 들어보셨죠? Docker는 바로 이런 문제를 해결해주는 컨테이너 기술입니다. 내가 만든 Spring Boot 앱을 소스 코드, 라이브러리, 실행 환경까지 통째로 포장해서 어디서든 똑같이 돌아가게 만들어주죠.\n### Docker, 왜 써야 할까?\n   일관된 환경: 개발, 테스트, 운영 환경을 모두 동일하게 맞춰서 '환경 탓' 할 일을 없애줍니다.\n   이식성: 노트북, 회사 서버, AWS 클라우드 어디든 Docker만 깔려있으면 바로 실행 가능합니다.\n   격리성: 각 앱을 독립된 공간(컨테이너)에 격리해서 서로 영향을 주지 않으니 안정성이 높아집니다.\n### Spring Boot 앱 Dockerizing\nSpring Boot 앱을 Docker 컨테이너로 만드는 과정은 \`Dockerfile\`이라는 레시피를 작성하는 것부터 시작합니다. 이 파일에 내 앱을 어떻게 만들고 실행할지 순서대로 적어주면, Docker가 알아서 이미지로 만들어줍니다.\n### 최적화 꿀팁: Multi-stage build\n소스 코드를 컴파일하는 환경과, 실제 앱을 실행하는 환경을 분리해서 최종 이미지 크기를 확 줄이는 기술입니다. 불필요한 개발 도구나 소스 코드는 빼고, 딱 실행에 필요한 파일들만 담아서 가볍고 안전한 이미지를 만들 수 있죠. 예제 코드에서 확인해보세요!`;
		default:
			// 해당하는 코드가 없으면 빈 문자열을 반환합니다.
			return "";
		}
	}

export function getPostCode(id) {
		switch (id) {
		case 1:
			// Java의 가장 기본적인 "Hello, World!" 출력 예제입니다.
			// 모든 Java 애플리케이션은 'main' 메소드에서 실행을 시작합니다.
			return `\n// public class [클래스 이름] { ... } : 자바의 모든 코드는 클래스 안에 작성되어야 합니다.\npublic class HelloWorld {\n\n    // public static void main(String[] args) { ... } : 프로그램의 시작점인 메인 메소드입니다.\n    public static void main(String[] args) {\n        \n        // System.out.println(\"...\"); : 괄호 안의 문자열을 콘솔에 출력하는 명령어입니다.\n        // 프로그래밍의 첫걸음으로 가장 많이 사용되는 예제입니다.\n        System.out.println("Hello, World!");\n    }\n}`;
		case 2:
			// Spring Boot를 사용하여 웹 애플리케이션을 시작하는 가장 간단한 예제입니다.
			// @SpringBootApplication 어노테이션 하나로 복잡한 설정들을 자동화합니다.
			return `\n// import ... : 다른 패키지에 있는 클래스를 가져와 사용하기 위해 필요합니다.\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n// @SpringBootApplication : 이 어노테이션이 클래스를 Spring Boot의 메인 클래스로 만들어줍니다.\n// 자동 설정, 컴포넌트 스캔 등 Spring Boot의 핵심 기능들이 활성화됩니다.\n@SpringBootApplication\npublic class MySpringBootApplication {\n\n    // Spring Boot 애플리케이션을 실행하는 메인 메소드입니다.\n    public static void main(String[] args) {\n        // SpringApplication.run(...) : 내장 웹 서버(Tomcat)를 실행하고 Spring 애플리케이션을 구동시킵니다.\n        SpringApplication.run(MySpringBootApplication.class, args);\n    }\n}`;
		case 3:
			// 객체 지향 프로그래밍(OOP)의 핵심 개념인 '클래스'와 '객체'를 보여주는 예제입니다.
			// 'Person'이라는 설계도(클래스)를 만들고, 그 설계도로 실제 사람(객체)을 만드는 과정을 보여줍니다.
			return `\n// 'Person'이라는 이름의 클래스를 정의합니다. 이 클래스는 사람의 속성과 행동을 정의하는 설계도입니다.\npublic class Person {\n    \n    // --- 속성 (필드) ---\n    // 클래스의 상태나 데이터를 나타냅니다.\n    String name; // 이름\n    int age;     // 나이\n\n    // --- 생성자 ---\n    // 클래스로부터 객체를 생성할 때 호출되며, 객체의 초기화를 담당합니다.\n    public Person(String name, int age) {\n        this.name = name; // this.name은 필드를, name은 파라미터를 가리킵니다.\n        this.age = age;\n    }\n\n    // --- 행동 (메소드) ---\n    // 클래스가 수행할 수 있는 동작을 정의합니다.\n    public void introduce() {\n        System.out.println("안녕하세요, 제 이름은 " + name + "이고, 나이는 " + age + "살입니다.");\n    }\n\n    // --- 사용 예시 ---\n    public static void main(String[] args) {\n        // new Person(...) : Person 클래스의 생성자를 호출하여 실제 '객체(인스턴스)'를 생성합니다.\n        Person person1 = new Person("강병주", 38);\n        Person person2 = new Person("제미니", 2);\n\n        // 생성된 객체의 메소드를 호출하여 동작을 수행합니다.\n        person1.introduce(); // person1 객체가 자기소개를 합니다.\n        person2.introduce(); // person2 객체가 자기소개를 합니다.\n    }\n}`;
		case 4:
			// Java의 어노테이션(Annotation) 사용법을 보여주는 예제입니다.
			// @Override는 부모 클래스의 메소드를 재정의했다는 것을 컴파일러에게 알려주는 역할을 합니다.
			return `\n// 'Animal'이라는 부모 클래스를 정의합니다.\nclass Animal {\n    void makeSound() {\n        System.out.println("동물이 소리를 냅니다.");\n    }\n}\n\n// 'Dog' 클래스가 'Animal' 클래스를 상속받습니다.\nclass Dog extends Animal {\n    \n    // @Override 어노테이션:\n    // 이 메소드가 부모 클래스(Animal)의 makeSound() 메소드를 재정의(Override)한 것임을 명시합니다.\n    // 만약 부모 클래스에 해당 메소드가 없거나, 메소드 시그니처가 다르면 컴파일 에러를 발생시켜 실수를 방지합니다.\n    @Override\n    void makeSound() {\n        System.out.println("멍멍!");\n    }\n}\n\npublic class AnnotationExample {\n    public static void main(String[] args) {\n        Dog myDog = new Dog();\n        myDog.makeSound(); // "멍멍!"이 출력됩니다.\n    }\n}`;
		case 5:
			// WebMvcConfigurer 인터페이스를 사용하여 정적 리소스(CSS, JS, 이미지 등)의 경로를 설정하는 예제입니다.
			// 특정 URL 경로 요청을 실제 파일 시스템의 특정 폴더로 연결할 수 있습니다.
			return `\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\n\n// @Configuration : 이 클래스가 Spring의 설정 파일임을 나타냅니다.\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n\n    // addResourceHandlers 메소드를 오버라이드하여 리소스 핸들러를 추가합니다.\n    @Override\n    public void addResourceHandlers(ResourceHandlerRegistry registry) {\n        \n        // registry.addResourceHandler(...) : 리소스와 매핑될 URL 경로 패턴을 지정합니다.\n        // "/static/**"은 URL이 '/static/'으로 시작하는 모든 요청을 의미합니다.\n        registry.addResourceHandler("/static/**")\n                \n                // .addResourceLocations(...) : 해당 URL 요청에 대해 탐색할 실제 파일 경로를 지정합니다.\n                // "classpath:/static/"은 빌드된 프로젝트의 'resources/static' 폴더를 의미합니다.\n                // 예: /static/css/style.css 요청은 resources/static/css/style.css 파일을 찾아 반환합니다.\n                .addResourceLocations("classpath:/static/");\n    }\n}`;
		case 6:
			// JWT(JSON Web Token)를 생성하고 검증하는 과정을 보여주는 개념적인 예제입니다.
			// 실제로는 JJWT(Java JWT)와 같은 라이브러리를 사용하여 구현합니다.
			return `\nimport io.jsonwebtoken.Jwts;\nimport io.jsonwebtoken.SignatureAlgorithm;\nimport io.jsonwebtoken.security.Keys;\nimport java.security.Key;\nimport java.util.Date;\n\n// 이 코드는 개념 설명을 위한 의사코드(pseudo-code)에 가깝습니다.\n// 실제 사용을 위해서는 jjwt-api, jjwt-impl, jjwt-jackson 등의 라이브러리 의존성 추가가 필요합니다.\npublic class JwtExample {\n\n    public static void main(String[] args) {\n        // 1. 비밀 키 생성\n        // 서명에 사용할 안전한 키를 생성합니다. 이 키는 서버만 알고 있어야 합니다.\n        Key secretKey = Keys.secretKeyFor(SignatureAlgorithm.HS256);\n\n        // 2. JWT 생성 (토큰 발급)\n        String jwt = Jwts.builder()\n                // "sub" (Subject): 토큰의 주체(여기서는 사용자 ID)를 설정합니다.\n                .setSubject("user123")\n                // "iss" (Issuer): 토큰 발급자를 설정합니다.\n                .setIssuer("my-app")\n                // "iat" (Issued At): 토큰 발급 시간을 설정합니다.\n                .setIssuedAt(new Date())\n                // "exp" (Expiration Time): 토큰 만료 시간을 설정합니다. (예: 1시간 후)\n                .setExpiration(new Date(System.currentTimeMillis() + 3600_000))\n                // 추가적인 정보(Claim)를 자유롭게 넣을 수 있습니다.\n                .claim("role", "USER")\n                // signWith: 생성한 비밀 키와 해싱 알고리즘으로 토큰에 서명합니다.\n                .signWith(secretKey)\n                // compact: 최종적으로 암호화된 문자열 형태의 JWT를 생성합니다.\n                .compact();\n\n        System.out.println("생성된 JWT: " + jwt);\n\n        // 3. JWT 검증 (토큰 파싱)\n        // 클라이언트로부터 받은 JWT가 위변조되지 않았는지, 만료되지 않았는지 확인합니다.\n        try {\n            var claims = Jwts.parserBuilder()\n                    // setSigningKey: 서명을 검증하기 위해 생성 시 사용했던 비밀 키를 설정합니다.\n                    .setSigningKey(secretKey)\n                    .build()\n                    // parseClaimsJws: JWT 문자열을 파싱하여 내용(Claims)을 추출합니다.\n                    // 서명이 유효하지 않거나 토큰이 만료되면 예외가 발생합니다.\n                    .parseClaimsJws(jwt)\n                    .getBody();\n\n            System.out.println("토큰 검증 성공!");\n            System.out.println("사용자 ID: " + claims.getSubject());\n            System.out.println("사용자 역할: " + claims.get("role"));\n\n        } catch (Exception e) {\n            System.out.println("토큰 검증 실패: " + e.getMessage());\n        }\n    }\n}`;
		case 7:
			return `\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n\n	@Override\n	public void addCorsMappings(CorsRegistry registry) {\n	\tregistry.addMapping("/**") // 모든 경로에 대해 CORS 설정을 적용합니다.\n	\t\t.allowedOrigins("http://localhost:3000") // 허용할 오리진(프론트엔드 주소)을 지정합니다.\n	\t\t.allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS") // 허용할 HTTP 메소드를 지정합니다.\n	\t\t.allowedHeaders("*") // 모든 HTTP 헤더를 허용합니다.\n	\t\t.allowCredentials(true); // 쿠키와 같은 자격 증명을 허용합니다.\n	}\n}`;
		case 8:
			return `\n@Configuration  // Spring 설정 클래스임을 명시\n@EnableWebSecurity  // Spring Security 웹 보안 활성화\npublic class SecurityConfig {\n\n    /**\n     * HTTP 보안 필터 체인을 구성하는 메서드\n     * Spring Security의 핵심 보안 설정을 정의\n     */\n    @Bean\n    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n        http\n            // HTTP 요청에 대한 인가(Authorization) 규칙 설정\n            .authorizeHttpRequests(authorize -> authorize\n                // "/login", "/register" 경로는 인증 없이 접근 허용 (회원가입, 로그인 페이지)\n                .requestMatchers("/login", "/register").permitAll()\n                // "/admin/**" 경로는 ADMIN 권한을 가진 사용자만 접근 가능\n                .requestMatchers("/admin/**").hasRole("ADMIN")\n                // 나머지 모든 요청은 인증된 사용자만 접근 가능\n                .anyRequest().authenticated()\n            )\n            // 폼 기반 로그인 설정\n            .formLogin(formLogin -> formLogin\n                // 사용자 정의 로그인 페이지 경로 설정\n                .loginPage("/login")\n                // 로그인 성공 후 리다이렉트할 기본 URL (강제 리다이렉트)\n                .defaultSuccessUrl("/home", true)\n                // 로그인 페이지에 모든 사용자 접근 허용\n                .permitAll()\n            )\n            // 로그아웃 설정\n            .logout(logout -> logout\n                // 로그아웃 요청을 처리할 URL\n                .logoutUrl("/logout")\n                // 로그아웃 성공 후 리다이렉트할 URL\n                .logoutSuccessUrl("/login?logout")\n                // 로그아웃 기능에 모든 사용자 접근 허용\n                .permitAll()\n            );\n        \n        // 설정된 HttpSecurity 객체를 빌드하여 SecurityFilterChain 반환\n        return http.build();\n    }\n\n    /**\n     * 비밀번호 암호화를 위한 PasswordEncoder 빈 등록\n     * BCrypt 해시 알고리즘을 사용하여 비밀번호를 안전하게 저장\n     */\n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        // BCrypt 암호화 방식 사용 (단방향 해시, 솔트 자동 생성)\n        return new BCryptPasswordEncoder();\n    }\n}`;
		case 9:
			return `// 기존 스레드 생성 방식\nThread platformThread = new Thread(() -> {\n    System.out.println("Platform Thread: " + Thread.currentThread());\n});\nplatformThread.start();\n\n// 가상 스레드 생성 방식 (Java 21+)\n// 1. Thread.ofVirtual().start() 사용\nThread virtualThread = Thread.ofVirtual().start(() -> {\n    System.out.println("Virtual Thread: " + Thread.currentThread());\n});\n\n// 2. Executors.newVirtualThreadPerTaskExecutor() 사용\ntry (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n    executor.submit(() -> {\n        System.out.println("Virtual Thread via Executor: " + Thread.currentThread());\n    });\n}\n\n// Thread.sleep()과 같은 블로킹 호출 시, 가상 스레드는 플랫폼 스레드를 점유하지 않고 양보합니다.\n// 이를 통해 수백만 개의 가상 스레드가 동시에 실행되는 것처럼 동작할 수 있습니다.`;
		case 10:
			return `// GC 동작을 관찰하기 위한 Java 코드 예제\n// 실행 옵션: -Xms256m -Xmx256m -XX:+PrintGCDetails -XX:+PrintGCTimeStamps\n\npublic class GCSample {\n    public static void main(String[] args) {\n        System.out.println("GC 동작 관찰 시작...");\n        \n        // 많은 객체를 생성하여 Minor GC를 유발\n        for (int i = 0; i < 1000; i++) {\n            createObjects(1024 * 10); // 10KB 크기의 객체 생성\n            try {\n                Thread.sleep(5);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }\n        \n        System.out.println("GC 동작 관찰 종료.");\n    }\n\n    private static void createObjects(int size) {\n        // 이 메서드가 끝나면 object 참조가 사라져, 생성된 객체는 GC의 대상이 됩니다.\n        byte[] object = new byte[size];\n    }\n}\n\n// 실행 결과(로그)를 통해 Young Generation(PSYoungGen)과 Old Generation(ParOldGen)의\n// 메모리 변화와 GC 발생 시간(user, sys, real)을 분석할 수 있습니다.`;
		case 11:
			return `// JUnit 5와 Mockito를 사용한 TDD 예제\n\n// 1. 테스트 대상 클래스 (처음에는 비어있음)\npublic class UserService {\n    private final UserRepository userRepository;\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n    public String getUserName(Long id) {\n        // 구현 전\n        return null; \n    }\n}\n\n// 2. 실패하는 테스트 코드 먼저 작성 (Red)\n@ExtendWith(MockitoExtension.class)\nclass UserServiceTest {\n    @Mock\n    private UserRepository mockUserRepository; // 가짜 Repository\n    @InjectMocks\n    private UserService userService; // 테스트 대상 객체\n\n    @Test\n    void getUserName_shouldReturnUserName_whenUserExists() {\n        // given: 준비\n        User user = new User(1L, "Rabbit");\n        when(mockUserRepository.findById(1L)).thenReturn(Optional.of(user));\n\n        // when: 실행\n        String userName = userService.getUserName(1L);\n\n        // then: 검증\n        assertEquals("Rabbit", userName);\n    }\n}\n\n// 3. 테스트를 통과하는 코드 작성 (Green)\npublic class UserService {\n    // ... (생성자 생략)\n    public String getUserName(Long id) {\n        return userRepository.findById(id)\n                .map(User::getName)\n                .orElse(null);\n    }\n}\n\n// 4. 코드 리팩토링 (Refactor) - 현재 코드는 충분히 간결하므로 생략`;
		case 12:
			return `public class StreamAdvancedExample {\n    public static void main(String[] args) {\n        List<Order> orders = getSampleOrders();\n\n        // 예제: 각 도시(city)별로 가장 비싼 주문(Order)을 찾기\n        Map<String, Optional<Order>> mostExpensiveOrderByCity = orders.stream()\n            .collect(Collectors.groupingBy(\n                order -> order.getCity(),\n                Collectors.maxBy(Comparator.comparing(Order::getAmount))\n            ));\n\n        mostExpensiveOrderByCity.forEach((city, order) -> \n            System.out.println(city + ": " + order.orElse(null))\n        );\n\n        // 예제: 주문 목록을 고객 이름(customerName)을 키로 하는 Map으로 변환\n        // 만약 동일 고객의 주문이 여러 개 있다면, 가장 최근 주문만 남긴다.\n        Map<String, Order> latestOrderByCustomer = orders.stream()\n            .collect(Collectors.toMap(\n                Order::getCustomerName,\n                order -> order,\n                (existingOrder, newOrder) -> \n                    newOrder.getOrderDate().isAfter(existingOrder.getOrderDate()) ? newOrder : existingOrder\n            ));\n        \n        latestOrderByCustomer.forEach((customer, order) -> \n            System.out.println(customer + "'s latest order: " + order)\n        );\n    }\n    // ... Order 클래스 및 샘플 데이터 생성 메서드 생략\n}`;
		case 13:
			return `// Kotlin의 가장 기본적인 "Hello, World!" 출력 예제입니다.\n// 'fun main() { ... }'은 프로그램의 시작점입니다.\nfun main() {\n    // println(...) : 괄호 안의 내용을 콘솔에 출력합니다.\n    println("Hello, Kotlin World!")\n\n    // 변수 선언 및 사용 예제\n    val message = "안녕하세요, Kotlin!"\n    println(message)\n\n    // --- 함수 정의 예제 ---\n    fun greet(name: String) {\n        println("Hello, $name!")\n    }\n    greet("Rabbit")\n\n    // --- 조건문 (if/else) 예제 ---\n    val num = 10\n    if (num > 5) {\n        println("$num은 5보다 큽니다.")\n    } else {\n        println("$num은 5보다 작거나 같습니다.")\n    }\n\n    // --- 반복문 (for) 예제 ---\n    for (i in 1..3) {\n        println("반복: $i")\n    }\n\n    // --- 데이터 타입 예제 ---\n    val integer: Int = 100\n    val text: String = "Kotlin"\n    val isTrue: Boolean = true\n    println("정수: $integer, 문자열: $text, 불리언: $isTrue")\n\n    // --- 클래스 (Class) 예제 ---\n    // 'data class'는 데이터를 담는 클래스를 간결하게 정의할 때 사용합니다.\n    data class User(val id: Int, val name: String)\n\n    val user1 = User(1, "Alice")\n    println("User: \${user1.name}, ID: \${user1.id})")\n\n    // --- 엔티티 (Entity) 예제 (데이터베이스 모델) ---\n    // 데이터베이스 테이블과 매핑되는 객체를 나타냅니다.\n    // 실제 DB 연동 코드는 생략되었습니다.\n    data class ProductEntity(val productId: Long, val productName: String, val price: Double)\n\n    val product = ProductEntity(101, "Kotlin Book", 29.99)\n    println("Product: \${product.productName}, Price: \${product.price})")\n\n    // --- DTO (Data Transfer Object) 예제 ---\n    // 계층 간 데이터 전송을 위해 사용되는 객체입니다.\n    // 예를 들어, 클라이언트로부터 데이터를 받거나 클라이언트로 데이터를 보낼 때 사용합니다.\n    data class OrderRequestDto(val userId: Int, val productId: Long, val quantity: Int)\n\n    val orderDto = OrderRequestDto(1, 101, 2)\n    println("Order Request: User \${orderDto.userId}, Product \${orderDto.productId}, Quantity \${orderDto.quantity})")\n\n    // --- 리포지토리 (Repository) 예제 (데이터 접근 계층) ---\n    // 데이터베이스 CRUD (Create, Read, Update, Delete) 작업을 추상화하는 인터페이스입니다.\n    // 실제 구현은 데이터베이스 기술(JPA, Spring Data JPA 등)에 따라 달라집니다.\n    interface UserRepository {\n        fun findById(id: Int): User?\n        fun save(user: User): User\n    }\n\n    // --- 서버 (Server) 예제 (간단한 API 엔드포인트 시뮬레이션) ---\n    // 웹 요청을 처리하는 서버의 한 부분을 간단히 시뮬레이션합니다.\n    // 실제 웹 프레임워크(Spring Boot, Ktor 등)에서는 어노테이션을 사용하여 정의됩니다.\n    fun handleUserRequest(userId: Int): String {\n        // 여기서는 간단히 문자열을 반환하지만, 실제로는 DB 조회, 비즈니스 로직 처리 등이 이루어집니다.\n        return "User with ID $userId processed."\n    }\n\n    // handleUserRequest 함수를 호출하고 그 반환 값을 출력하는 코드\n	println(handleUserRequest(user1.id))\n}`;
		case 14:
			return `// --- 1. SchedulerJob.java (스케줄러 Job 정보 엔티티) ---\n// 데이터베이스에 저장될 스케줄링 작업의 구조를 정의합니다.\n// Lombok의 @Data, @EqualsAndHashCode, JPA의 @Entity 등을 사용하여 간결하게 작성되었습니다.\npackage com.example.entity;\n\nimport com.example.common.entity.BaseEntity;\nimport jakarta.persistence.*;\nimport lombok.Data;\nimport lombok.EqualsAndHashCode;\nimport org.hibernate.annotations.Comment;\n\n@EqualsAndHashCode(callSuper = true)\n@Entity\n@Data\npublic class SchedulerJob extends BaseEntity {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Comment("PK ID")\n    private Long id;\n\n    @Comment("스케줄러 Job 이름")\n    private String jobName;\n\n    @Comment("스케줄러 Job 그룹")\n    private String jobGroup;\n\n    @Comment("스케줄러 설명")\n    private String description;\n\n    @Comment("스케줄러 실행 Cron 표현식")\n    private String cronExpression;\n\n    @Comment("스케줄러 상태 (RUNNING, PAUSED)")\n    private String status;\n}\n\n// --- 2. SchedulerController.java (스케줄러 등록 REST API) ---\n// 클라이언트의 HTTP 요청을 받아 스케줄러 서비스를 호출하는 컨트롤러입니다.\n// @PostMapping을 통해 /api/schedulers 경로로 POST 요청이 오면 createJob 메서드가 실행됩니다.\npackage com.example.controller;\n\nimport com.example.entity.SchedulerJob;\nimport com.example.service.SchedulerService;\nimport lombok.RequiredArgsConstructor;\nimport org.quartz.SchedulerException;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\n\n@RestController\n@RequestMapping("/api/schedulers")\n@RequiredArgsConstructor\npublic class SchedulerController {\n    private final SchedulerService schedulerService;\n\n    @PostMapping\n    public ResponseEntity<?> createJob(@RequestBody SchedulerJob job) throws SchedulerException {\n        try {\n            SchedulerJob savedJob = schedulerService.createJob(job);\n            return ResponseEntity.ok(savedJob);\n        } catch (IllegalArgumentException e) {\n            return ResponseEntity.badRequest().body(e.getMessage());\n        }\n    }\n}\n\n// --- 3. SchedulerService.java (핵심 비즈니스 로직) ---\n// 스케줄러 Job을 생성, 저장하고 실제 Quartz 스케줄러에 등록/삭제하는 로직을 담당합니다.\npackage com.example.service;\n\nimport com.example.entity.SchedulerJob;\nimport com.example.repository.SchedulerJobRepository;\nimport lombok.RequiredArgsConstructor;\nimport org.quartz.*;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\n@Service\n@RequiredArgsConstructor\npublic class SchedulerService {\n    private final Scheduler scheduler; // Quartz 스케줄러\n    private final SchedulerJobRepository schedulerJobRepository;\n\n    @Transactional\n    public SchedulerJob createJob(SchedulerJob job) throws SchedulerException {\n        if (!CronExpression.isValidExpression(job.getCronExpression())) {\n            throw new IllegalArgumentException("Invalid Cron Expression.");\n        }\n        \n        // 1. DB에 Job 정보 저장\n        job.setStatus("RUNNING");\n        SchedulerJob savedJob = schedulerJobRepository.save(job);\n\n        // 2. Quartz 스케줄러에 Job 등록\n        scheduleJob(savedJob);\n\n        return savedJob;\n    }\n\n    public void scheduleJob(SchedulerJob job) throws SchedulerException {\n        JobDetail jobDetail = buildJobDetail(job);\n        CronTrigger trigger = buildCronTrigger(job);\n        scheduler.scheduleJob(jobDetail, trigger);\n    }\n\n    private JobDetail buildJobDetail(SchedulerJob job) {\n        // Job을 실행할 클래스를 지정합니다. (실제 실행될 로직을 담은 클래스)\n        // 여기서는 예시로 SimpleJob.class를 사용합니다.\n        return JobBuilder.newJob(SimpleJob.class)\n                .withIdentity(job.getJobName(), job.getJobGroup())\n                .withDescription(job.getDescription())\n                .build();\n    }\n\n    private CronTrigger buildCronTrigger(SchedulerJob job) {\n        return TriggerBuilder.newTrigger()\n                .withIdentity(job.getJobName() + "-trigger", job.getJobGroup())\n                .withCronSchedule(job.getCronExpression())\n                .build();\n    }\n    \n    // 실제 Job 실행 로직을 담은 클래스\n    public static class SimpleJob implements Job {\n        @Override\n        public void execute(JobExecutionContext context) {\n            System.out.println("Executing Job: " + context.getJobDetail().getKey());\n        }\n    }\n}\n\n// --- 4. SchedulerInitializer.java (서버 시작 시 스케줄러 초기화) ---\n// 애플리케이션이 시작될 때 데이터베이스에 저장된 \'RUNNING\' 상태의 모든 Job을\n// Quartz 스케줄러에 다시 등록하는 역할을 합니다.\n// 이를 통해 서버가 재시작되어도 기존 스케줄링 정보가 유지됩니다.\npackage com.example.config;\n\nimport com.example.entity.SchedulerJob;\nimport com.example.repository.SchedulerJobRepository;\nimport com.example.service.SchedulerService;\nimport lombok.RequiredArgsConstructor;\nimport lombok.extern.slf4j.Slf4j;\nimport org.quartz.JobKey;\nimport org.quartz.Scheduler;\nimport org.quartz.SchedulerException;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.stereotype.Component;\n\nimport java.util.List;\n\n@Slf4j\n@Component\n@RequiredArgsConstructor\npublic class SchedulerInitializer implements CommandLineRunner {\n\n    private final Scheduler scheduler;\n    private final SchedulerJobRepository schedulerJobRepository;\n    private final SchedulerService schedulerService;\n\n    @Override\n    public void run(String... args) {\n        log.info("Initializing schedulers from database...");\n        try {\n            List<SchedulerJob> jobList = schedulerJobRepository.findAll();\n            for (SchedulerJob job : jobList) {\n                JobKey jobKey = new JobKey(job.getJobName(), job.getJobGroup());\n                // 스케줄러에 이미 등록된 Job인지 확인\n                if (!scheduler.checkExists(jobKey) && "RUNNING".equals(job.getStatus())) {\n                    schedulerService.scheduleJob(job);\n                    log.info("Scheduled job {} from database.", job.getJobName());\n                }\n            }\n        } catch (SchedulerException e) {\n            log.error("Error while initializing schedulers", e);\n        }\n        log.info("Scheduler initialization finished.");\n    }\n}\n`;
		case 15:
			return `// Spring Boot 애플리케이션을 Docker 이미지로 만드는 방법을 보여주는 Dockerfile 예제입니다.\n// Multi-stage build를 사용하여 최종 이미지의 크기를 최적화합니다.\n# --- 1단계: 빌드(Build) 환경 ---\n# Gradle과 JDK 17을 포함한 이미지를 기반으로 빌드 환경을 구성합니다.\n# \'AS builder\'는 이 단계를 \'builder\'라는 이름으로 참조할 수 있게 해줍니다.\nFROM gradle:jdk17 AS builder\n\n# 작업 디렉토리를 /app으로 설정합니다.\nWORKDIR /app\n\n# 소스 코드를 컨테이너의 /app 디렉토리로 복사합니다.\n# build.gradle, settings.gradle을 먼저 복사하여 의존성을 캐싱하고 빌드 속도를 높입니다.\nCOPY build.gradle settings.gradle /app/\nCOPY src /app/src\n\n# Gradle wrapper를 실행 가능하게 만듭니다. (만약 gradlew를 사용한다면)\n# RUN chmod +x ./gradlew\n\n# Spring Boot 애플리케이션을 빌드하여 실행 가능한 JAR 파일을 생성합니다.\n# \'--build-cache\' 옵션은 Gradle의 빌드 캐시를 활성화하여 반복 빌드 속도를 향상시킵니다.\nRUN gradle build --no-daemon\n\n# --- 2단계: 실행(Runtime) 환경 ---\n# 실제 애플리케이션을 실행할 환경입니다.\n# JRE(Java Runtime Environment)만 포함된 가벼운 이미지를 사용하여 최종 이미지 크기를 줄입니다.\nFROM openjdk:17-jdk-slim\n\n# 작업 디렉토리를 /app으로 설정합니다.\nWORKDIR /app\n\n# 빌드 단계(builder)에서 생성된 JAR 파일을 실행 환경으로 복사합니다.\n# build/libs/ 폴더에 있는 *.jar 파일을 app.jar 라는 이름으로 복사합니다.\nCOPY --from=builder /app/build/libs/\*.jar /app/app.jar\n\n# 컨테이너가 외부에 노출할 포트를 8080으로 지정합니다.\nEXPOSE 8080\n\n# 컨테이너가 시작될 때 실행될 명령어를 정의합니다.\n# \'java -jar /app/app.jar\' 명령으로 Spring Boot 애플리케이션을 실행합니다.\nENTRYPOINT [\"java\", \"-jar\", \"/app/app.jar\"]`; 
		case 16:
			return `안녕하세요! 백엔드 개발자 Rabbit입니다.\n\r최근 여러 면접을 보면서 스스로 아직 노력과 준비가 부족하다는 걸 느꼈습니다.\n그동안 포트폴리오 작성이나 프로젝트 설명에 AI를 너무 의존했던 것 같아,\n앞으로는 제가 직접 작성하고 사용했던 코드들을 스스로 정리하며 설명하는 습관을 들이려 합니다.\n\r면접 중에 제가 했던 작업을 용어로만 표현하다 보니,\n정작 그 개념을 깊이 있게 설명하지 못했던 점이 큰 아쉬움으로 남았습니다.\n그래서 앞으로는 면접에서 답변하지 못했던 용어나 배워야 할 기술들을 하나씩 정리하며 성장해 나가려 합니다.\n\r그중 하나로, 배치 처리 최적화를 적용했던 경험이 있습니다.\n당시 Cafe24 API를 이용해 쇼핑몰과 ERP 간 데이터를 동기화하는 기능을 개발하고 있었는데,\n상품 정보의 수천 건의 데이터를 개별 API 요청으로 처리하다 보니 초당 요청 횟수 제한에 자주 걸리는 문제가 발생했습니다.\n\r처음에는 단순히 요청 대기 시간을 조절하거나, 스레드 수를 줄이는 방식으로 시도했지만, 이 방식은 근본적인 해결책이 되 못했고 전체 처리 속도 역시 너무 느려졌습니다.\n그래서 접근 방식을 완전히 바꿔, 실시간 API 호출을 최소화하고 내부 시스템에서 데이터를 비동기적으로 처리하는 구조를 설계했습니다.\n\r우선, Cafe24 API에서 필요한 데이터를 리스트 형태로 한 번에 가져오도록 요청 구조를 변경하고,\n 그다음 수집된 데이터를 데이터베이스에 임시 저장한 뒤, Spring Scheduler를 활용해 주기적으로 데이터를 조회/갱신하는 배치 프로세스를 구성했습니다.\n대량의 데이터를 다루는 과정에서 불필요한 중복 업데이트를 방지하기 위해 Java Stream API를 활용하여 데이터 비교 및 필터링 로직을 구현했습니다.\n또한 변경된 데이터만 효율적으로 반영되도록 Delta Sync 방식을 적용하여,\n전체 데이터를 반복적으로 갱신하지 않고 변경분만 업데이트함으로써 처리 효율을 높였습니다.\n\r아쉽게도 그때 작업했던 코드를 이제 볼 수 없지만 개인 프로젝트를 통해서 확인해 볼 수 있는 코드를 만들어보겠습니다.\n\r코드를 만들고 난 후에는 Delta Sync 에 대해 작성 해보도록 하겠습니다.\n\r감사합니다.`;
		default:
			// 해당하는 코드가 없으면 빈 문자열을 반환합니다.
			return "";
		}
	}